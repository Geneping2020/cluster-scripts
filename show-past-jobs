#!/bin/bash

# Looks up the finished jobs of the current user from the  last DAYS days (default 7)
# and prints the number, name and submission time.


# Colour codes for failed/succeeded jobs.
# Uses bash colour codes.
FAILED_CC="1;31"
SUCCEEDED_CC="1;32"

if [[ "$1" == "help" ]] ; then
    echo "Usage: show-past-jobs [-e] [-d DAYS] [-u USER]"
    echo "    [-e]  : (Optional) select jobs by end time rather than start time."
    echo "    [-d DAYS]: (Optional) Integer defining how many days back to look."
    echo "            Defaults to 7."
    echo "    [-u USER]: (Optional) Requires an argument for DAYS. Defaults to current user."
    exit
fi

N_DAYS=7
LOOKUP_USER="$USER"

while :
do
    case "$1" in 
      -d)
        N_DAYS=$2
        shift 2
        ;;
      -u)
        LOOKUP_USER="$2"
        shift 2
        ;;
      -e)
        END_TIME="True"
        shift
        ;;
      *)
        break
        ;;
    esac
done

convert_from_seconds() {
    # Converts number of seconds to useful format
    SECONDS=$1
    DAYS=$(($SECONDS / 86400))
    SECONDS=$(($SECONDS - $DAYS * 86400))
    HOURS=$(($SECONDS / 3600))
    SECONDS=$(($SECONDS - $HOURS * 3600))
    MINUTES=$(($SECONDS / 60))
    SECONDS=$(($SECONDS - $MINUTES * 60))
    DURATION=''
    if [[ $DAYS -gt 0 ]] ; then DURATION="$DURATION${DAYS}d "; fi
    if [[ $HOURS -gt 0 ]] ; then DURATION="$DURATION${HOURS}h "; fi
    if [[ $MINUTES -gt 0 ]] ; then DURATION="$DURATION${MINUTES}m "; fi
    DURATION="$DURATION${SECONDS}s"
}

# Look up the target jobs and pull out the desired info
if [[ ! -z "$END_TIME" ]] ; then
    PAST_JOBS=`qacct -u "$LOOKUP_USER" -j -E -d "$N_DAYS"`    
else
    PAST_JOBS=`qacct -u "$LOOKUP_USER" -j -d "$N_DAYS"`
fi
NAMES=(`echo "$PAST_JOBS" | grep "^jobname" | awk '{print $2}'`)
NUMBERS=(`echo "$PAST_JOBS" | grep "^jobnumber" | awk '{print $2}'`)
TASKIDS=(`echo "$PAST_JOBS" | grep "^taskid" | awk '{print $2}'`)
OLD_IFS=$IFS
IFS=$'\n'
QSUB_TIMES=(`echo "$PAST_JOBS" | grep "^qsub_time" | cut -d ' ' -f 2-`)
START_TIMES=(`echo "$PAST_JOBS" | grep "^start_time" | cut -d ' ' -f 2-`)
END_TIMES=(`echo "$PAST_JOBS" | grep "^end_time" | cut -d ' ' -f 2-`)
EXIT_STATUSES=(`echo "$PAST_JOBS" | grep "^exit_status" | cut -d ' ' -f 2-`)    
IFS=$OLD_IFS
HOSTNAMES=(`echo "$PAST_JOBS" | grep "^hostname" |  awk '{print $2}'`)

# Loop through extracted info and format it for printing
OUT=''
HEADER="Showing past jobs for user ${LOOKUP_USER}:\nJob # \tTask ID     Name     \t    Exit Status  \tHost \t\tDuration \t Sub Time"
for i in `seq 0	"$((${#NAMES[@]}-1))"`;	do
        # Colour code the exit status:
        EXIT_STATUS=`echo "${EXIT_STATUSES[$i]}" | tr -d '[:space:]'`
        # If an array job, get the taskid:
        if [[ "${TASKIDS[$i]}" == "undefined" ]] ; then TASK_ID=""; else TASK_ID="${TASKIDS[$i]}"; fi
        # Extract the first section of the hostname:
        HOSTNAME=(${HOSTNAMES[$i]//./ })
        # Change the duration to a useful format:
        convert_from_seconds $((`date --date="${END_TIMES[$i]}" +%s` - `date --date="${START_TIMES[$i]}" +%s`))
        # Limit the length of the name to 20 characters:
        NAME=${NAMES[$i]}
        if [[ ${#NAME} -gt 20 ]] ; then NAME="${NAME:0:7}...${NAME: -7}"; fi
        if [[ ${#NAME} -lt 8 ]] ; then NAME="${NAME}\t"; fi
        if [[ ${#NAME} -lt 16 ]] ; then NAME="${NAME}\t"; fi
        if [[ ${#EXIT_STATUS} -lt 8 ]] ; then EXIT_STATUS="${EXIT_STATUS}\t"; fi
        if [[ ${#EXIT_STATUS} -lt 16 ]] ; then EXIT_STATUS="${EXIT_STATUS}\t"; fi
        if [[ ${#DURATION} -lt 8 ]] ; then DURATION="${DURATION}\t" ; fi
        if [[ ${#DURATION} -lt 16 ]] ; then DURATION="${DURATION}\t" ; fi
        if [[ "$EXIT_STATUS" == "0\t\t" ]] ; then EXIT_STATUS="\e[${SUCCEEDED_CC}m$EXIT_STATUS\e[m"; fi
        if [[ "$EXIT_STATUS" == "1\t\t" ]] ; then EXIT_STATUS="\e[${FAILED_CC}m$EXIT_STATUS\e[m"; fi
        OUT="$OUT\n${NUMBERS[$i]}\t${TASK_ID}\t${NAME}\t${EXIT_STATUS}${HOSTNAME[0]}\t${DURATION}${QSUB_TIMES[$i]}" 
done

# Output everything sorted by job number:
echo -e "$HEADER"
echo "--------------------------------------------------------------------------------------------------"
echo -e	$OUT | sort -k 1,1nr -k 2,2n
